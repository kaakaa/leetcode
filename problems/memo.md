# 方針

- thumbsdown 率が高いやつはスキップ

## 37

- [backtracking](https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AF%E3%83%88%E3%83%A9%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0)
- 人間が解くようにやろうとしても解けない。9x9 なので総当たりでも計算量は大したことない。

## 41

- Sort して前から数えていくで解けるような...? Hard...?

## 44

- DP 使うの気づけないな...

## 45

- #44 を受けて２次元配列の DP しようとしたら時間・メモリともにオーバー
  - 3 \* 10^4 の配列で O(n^2)は無理か...
- 単純な方法で解いたけど、終了条件で頭がおかしくなってしまった。難しい。

## 60

- 結構上手く書けた思ったけど、性能底辺ですね...枝刈りする方法があるのかな
- メモ化したらちょっと早くなったけど全然だな...

## 61

- スッと解けるかと思ったけど完成してみると汚いな。ListNode 系はなんかスッキリ書けない。
- 処理時間かかりすぎ。そんなに無駄なことしてるかなぁ？
- [この解放](https://cheonhyangzhang.gitbooks.io/leetcode-solutions/content/61_rotate_list__medium.html)は速いな。2 回ループしてるから遅いと思ったけど、Queue のサイズチェックとか入れ替えする方がそりゃ遅くなるか...

## 70

- フィボナッチか。図を書くまで気づけなかった。

## 71

- 難なく解けたけど速度が遅め。まぁ split する分が時間食ってるんだろうな。

## 73

- O(M+N)のスペースを使う方ならわかったけど、定数スペースの方はわからんかった。なるほどな。

## 77

- 問題の条件をちゃんと読めてなかったな
- あと、List<List<>>が出てくると頭が混乱しがち

## 86

- 結構上位なアルゴリズムで解けた。（ただ結構悩んだ）
- 公式の Solution では Before/After それぞれ構築して最後に繋げてるけど、in-place なやり方でできた

## 90

- List だと順序性ができてしまうから重複チェックがちゃんとできないね...
- 無理やり Sort を入れてみたら処理時間がだいぶかかるようになってしまった

## 92

- 直感的に swap 使って実装。良いアルゴリズムだったっぽい（ただループ内の状態を意識しながらなので少し複雑）

## 103

- 幅優先探索。すぐわかった。性能もそこそこ。良かった。

## 107

- ケアレスミス...ちゃんとやろう。

## 110

- ヤバイ。easy なのにわからん。頭が回ってないのかもしれない。

## 113

- 終了条件をミスって WA x 2。日が空いたのがダメなのかもしれん。

## 119

- 0 開始なのを勘違いしていてちょっと悩んだ。Downvote が多いのはそのせいかな。

## 120

- なんかいろいろ勘違いしていて間違いまくった...

## 123

- O(n^2) のやり方しか思い付かず撃沈
- あと、問題読み違えてた。売った日にまた買ってもいいのか。

## 129

- そうか...これも DP なのか...全然気づかず TLE 連発してた
- refs: https://qiita.com/KueharX/items/ac025ce072d98751e688

## 143

- LinkedList を辿るときは fast/slow pointer で辿ると早い。覚えなきゃ。

## 174

- 全然駄目だった。dp 使うことまではわかるけど、どう使えばいいかだな...
- 前から見ていくと途中での最小値が正解とは限らないからいろいろ覚えておかなきゃいけないので、後から見ていくという発想の切り替え必要
  - コード組み始めると最初の発想に固執してしまうのよくないな

## 179

- Comparator 実装するところは Solution と一緒だったけど、中身を無駄に考えすぎてた。お互い足し合わせた文字列で比べればいいだけか...

## 208

- Trie というデータ構造の話
- Autocomplete 等の前方一致で使われるアルゴリズムらしい
